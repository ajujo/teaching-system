Chapter 3
63
Using a utility function, we split the full name into first and last names. Then, we attempt to
retrieve the user from the database or create a new one if it doesn't exist. We also retrieve the
current step context and add metadata about the user to the output, which will be reflected in
the metadata of the user ZenML output artifact:
    logger.info(f"Getting or creating user: {user_full_name}")
    first_name, last_name = utils.split_user_full_name(user_full_name)
    user = UserDocument.get_or_create(first_name=first_name, last_
name=last_name)
    step_context = get_step_context()
    step_context.add_output_metadata(output_name="user", metadata=_get_
metadata(user_full_name, user))
    return user
Additionally, we define a helper function called _get_metadata(), which builds a dictionary
containing the query parameters and the retrieved user information, which will be added as
metadata to the user artifact:
def _get_metadata(user_full_name: str, user: UserDocument) -> dict:
    return {
        "query": {
            "user_full_name": user_full_name,
        },
        "retrieved": {
            "user_id": str(user.id),
            "first_name": user.first_name,
            "last_name": user.last_name,
        },
    }
We will move on to the crawl_links ZenML step, which collects the data from the provided links.
The code begins by importing essential modules and libraries for web crawling:
from urllib.parse import urlparse
from loguru import logger
