RAG Inference Pipeline
332
By implementing self-querying, we ensure that critical metadata required for our use case is explicitly extracted and used during retrieval. This approach overcomes the limitations of relying
solely on the semantics of the embeddings to capture all necessary aspects of a query.
Now that we've implemented the SelfQuery class, let's provide an example. Run the following
code using the python -m llm_engineering.application.rag.self_query CLI command:
    query = Query.from_str("I am Paul Iusztin. Write an article about the
best types of advanced RAG methods.")
    self_query = SelfQuery()
    query = self_query.generate(query)
    logger.info(f"Extracted author_id: {query.author_id}")
    logger.info(f"Extracted author_full_name: {query.author_full_name}")
We get the following results where the author's full name and ID were extracted correctly:
2024-09-18 18:02:10.362 | INFO - Extracted author_id: 900fec95-d621-4315-
84c6-52e5229e0b96
2024-09-18 18:02:10.362 | INFO - Extracted author_full_name: Paul Iusztin
Now that we understand how self-querying works, let's explore how it can be used together with
filtered vector search within the retrieval optimization step.
Advanced RAG retrieval optimization: filtered vector search
Vector search is pivotal in retrieving relevant information based on semantic similarity. A plain
vector search, however, can introduce significant challenges that affect both the accuracy and
latency of information retrieval. This is primarily because it operates solely on the numerical
proximity of vector embeddings without considering the contextual or categorical nuances that
might be crucial for relevance.
One of the primary issues with plain vector search is retrieving semantically similar but contextually irrelevant documents. Since vector embeddings capture general semantic meanings, they
might assign high similarity scores to content that shares language patterns or topics but doesn't
align with the specific intent or constraints of the query. For instance, searching for "Java" could
retrieve documents about the programming language or the Indonesian island, depending solely
on semantic similarity, leading to ambiguous or misleading results.
Moreover, as the size of the dataset increases, plain vector search can suffer from scalability issues.
The lack of filtering means the search algorithm has to compute similarities across the entire
vector space, which can significantly increase latency.
