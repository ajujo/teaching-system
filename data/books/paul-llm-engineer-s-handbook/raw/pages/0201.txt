RAG Feature Pipeline
170
    All data transformations logic for the embedding step is done here
    """
    def embed(self, data_model: ChunkT) -> EmbeddedChunkT:
        return self.embed_batch([data_model])[0]
    def embed_batch(self, data_model: list[ChunkT]) -> 
list[EmbeddedChunkT]:
        embedding_model_input = [data_model.content for data_model in 
data_model]
        embeddings = embedding_model(embedding_model_input, to_list=True)
        embedded_chunk = [
            self.map_model(data_model, cast(list[float], embedding))
            for data_model, embedding in zip(data_model, embeddings, 
strict=False)
        ]
        return embedded_chunk
    @abstractmethod
    def map_model(self, data_model: ChunkT, embedding: list[float]) -> 
EmbeddedChunkT:
        pass
Letâ€™s look only at the implementation of the ArticleEmbeddingHandler(), as the other handlers 
are highly similar. As you can see, we only have to implement the map_model() method, which 
takes a chunk of input and computes the embeddings in batch mode. Its scope is to map this 
information to an EmbeddedArticleChunk Pydantic entity.
class ArticleEmbeddingHandler(EmbeddingDataHandler):
    def map_model(self, data_model: ArticleChunk, embedding: list[float]) 
-> EmbeddedArticleChunk:
        return EmbeddedArticleChunk(
            id=data_model.id,
            content=data_model.content,
            embedding=embedding,
            platform=data_model.platform,
            link=data_model.link,
