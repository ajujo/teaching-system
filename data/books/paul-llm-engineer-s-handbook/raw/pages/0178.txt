Chapter 4
147
        cleaned_document = CleaningDispatcher.dispatch(document)
        cleaned_documents.append(cleaned_document)
    step_context = get_step_context()
    step_context.add_output_metadata(output_name="cleaned_documents", 
metadata=_get_metadata(cleaned_documents))
    return cleaned_documents
The computed metadata is similar to what we logged in the query_data_warehouse() step. Thus, 
let’s move on to chunking and embedding.
Chunk and embed the cleaned documents
Similar to how we cleaned the documents, we delegate the chunking and embedding logic to 
a dispatcher who knows how to handle each data category. Note that the chunking dispatcher 
returns a list instead of a single object, which makes sense as the document is split into multiple 
chunks. We will dig into the dispatcher in the “The dispatcher layer” section of this chapter.
@step
def chunk_and_embed(
    cleaned_documents: Annotated[list, "cleaned_documents"],
) -> Annotated[list, "embedded_documents"]:
    metadata = {"chunking": {}, "embedding": {}, "num_documents": 
len(cleaned_documents)}
    embedded_chunks = []
    for document in cleaned_documents:
        chunks = ChunkingDispatcher.dispatch(document)
        metadata["chunking"] = _add_chunks_metadata(chunks, 
metadata["chunking"])
        for batched_chunks in utils.misc.batch(chunks, 10):
            batched_embedded_chunks = EmbeddingDispatcher.
dispatch(batched_chunks)
            embedded_chunks.extend(batched_embedded_chunks)
    metadata["embedding"] = _add_embeddings_metadata(embedded_chunks, 
metadata["embedding"])
    metadata["num_chunks"] = len(embedded_chunks)
