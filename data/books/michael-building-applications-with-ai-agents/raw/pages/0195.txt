        kwargs={kwargs})")
   log_to_loki("tool.optimize_delivery", f"delivery_type={delivery_type}")
   return "delivery_optimization_complete"
@tool
def manage_disruption(disruption_type: str = None, **kwargs) -> str:
   """Manage supply chain disruptions, contingency planning, 
   and risk mitigation."""
   print(f"[TOOL] manage_disruption(disruption_type={disruption_type}, 
        kwargs={kwargs})")
   log_to_loki("tool.manage_disruption", f"disruption_type={disruption_type}")
   return "disruption_managed"
TRANSPORTATION_TOOLS = [track_shipments, arrange_shipping, coordinate_operations, 
    manage_special_handling, process_returns, optimize_delivery, 
    manage_disruption, send_logistics_response]
# Supplier & Compliance Specialist Tools
@tool
def evaluate_suppliers(supplier_name: str = None, **kwargs) -> str:
   """Evaluate supplier performance, conduct audits, 
   and manage supplier relationships."""
   print(f"[TOOL] evaluate_suppliers(supplier_name={supplier_name}, 
        kwargs={kwargs})")
   log_to_loki("tool.evaluate_suppliers", f"supplier_name={supplier_name}")
   return "supplier_evaluation_complete"
@tool
def handle_compliance(compliance_type: str = None, **kwargs) -> str:
   """Manage regulatory compliance, customs, documentation, 
   and certifications."""
   print(f"[TOOL] handle_compliance(compliance_type={compliance_type}, 
        kwargs={kwargs})")
   log_to_loki("tool.handle_compliance", f"compliance_type={compliance_type}")
   return "compliance_handled"
SUPPLIER_TOOLS = [evaluate_suppliers, handle_compliance, send_logistics_response]
Traceloop.init(disable_batch=True, app_name="supply_chain_logistics_agent")
llm = ChatOpenAI(model="gpt-4o", temperature=0.0, 
    callbacks=[StreamingStdOutCallbackHandler()], verbose=True)
# Bind tools to specialized LLMs
inventory_llm = llm.bind_tools(INVENTORY_TOOLS)
transportation_llm = llm.bind_tools(TRANSPORTATION_TOOLS)
supplier_llm = llm.bind_tools(SUPPLIER_TOOLS)
With tools grouped, we bind them to separate language model instances for each spe‚Äê
cialist. This allows for tailored prompts and reduces context size per agent, enhancing
focus and efficiency. Multiagent architectures like this enable parallel processing (e.g.,
one agent optimizing delivery while another evaluates suppliers) cutting response
times in high-volume logistics. The shared state ensures seamless handoffs.
How Many Agents Do I Need? 
| 
173
