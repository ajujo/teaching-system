adaptive load balancing. Akka is particularly well suited for high-throughput,
low-latency applications requiring tight control over concurrency, and it has been
used in production environments ranging from telecom systems to trading
platforms.
This actor-style design aligns naturally with multiagent coordination, where each
agent maintains its own identity, role, and internal state. Actor systems enable these
agents to be invoked dynamically, react to messages or events, and manage complex
workflows through message passing rather than shared state or global control.
Because this book emphasizes Python-based implementations for multiagent systems
(e.g., using LangChain and related libraries), we'll illustrate the actor model with a
Ray example integrated into the supply chain system. Similar principles apply to
Orleans (primarily .NET-based, ideal for Windows ecosystems or enterprise integra‐
tions) and Akka (JVM-focused, suited for high-performance Java/Scala apps), but
their code would require language-specific adaptations beyond our Python-centric
scope.
In the context of the supply chain multiagent system, the specialist agents (e.g., inven‐
tory, transportation) are implemented as Ray actors with per-session isolation. Each
session (identified by operation_id) gets its own actor instance per specialist type,
ensuring clean state management-isolated history or caches per session-while
guaranteeing sequential execution within each actor for tasks in that session. This
avoids cross-session contamination and enables parallel processing across sessions in
a cluster. A session manager actor tracks and creates these on demand. Here's the core
Ray actor class for a specialist, which processes tasks sequentially and maintains iso‐
lated session state:
@ray.remote
class SpecialistActor:
    def __init__(self, name: str, specialist_llm, tools: list,
                 system_prompt: str):
        self.name = name
        self.llm = specialist_llm
        self.tools = {t.name: t for t in tools}
        self.prompt = system_prompt
        self.internal_state = {}
    def process_task(self, operation: dict, messages: Sequence[BaseMessage]):
        if not operation:
            operation = {"operation_id": "UNKNOWN", "type": "general",
                         "priority": "medium", "status": "active"}
        operation_json = json.dumps(operation, ensure_ascii=False)
        full_prompt = self.prompt + f"\n\nOPERATION: {operation_json}"

        full = [SystemMessage(content=full_prompt)] + messages
        first = self.llm.invoke(full)
Actor Frameworks: Ray, Orleans, and Akka
|
197
